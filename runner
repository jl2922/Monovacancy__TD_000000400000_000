#!/usr/bin/env python
"""
Vacancy Formation and Migration Test Driver
Works for Both Common Cubic and HCP Crystals, at 0 K and 0 GPa

This test driver first performs calculation with several fixed size supercells,
then extrapolates these results to obtain the dilute limit.
Migration is obtained with nudged elastic band method.

2016-04-06 Junhao Li <streaver91@gmail.com>
* Change the output format to conform with the new property definition.
* Add the calculation of relaxation volume and elastic multipoles.
* Change the version number to 001

Author: Junhao Li <streaver91@gmail.com>
"""
# Python Modules
import re
import json
import os

# Vacancy Driver Modules
import config as C
import functions as F
from vacancy import Vacancy

# Generate OrderedDict for all properties to report
def packResult(res):
    print '[Packing results]'
    instanceId = 1 # Instance id start from 1
    driverPath = os.path.dirname(os.path.abspath(__file__))
    instances = []
    # Loop through each property definition
    for pd in C.PROPERTY_DEFINITIONS:
        print 'packing results for: ' + pd
        instance = {
            'instance-id': instanceId
        }
        with open(driverPath + ('/definitions/%s.edn' % pd), 'r') as f:
            content = f.read()
            # Obtain property id
            tmp = re.search('property-id\" \"([^\"]+)\"', content, re.M)
            propertyId = tmp.group(1)
            instance['property-id'] = propertyId
            # Obtain property keys
            tmp = re.findall('\"([^\"]+)\" \{', content)
            for prop in tmp:
                resKey = prop # corresponding key in res object
                if prop[:5] == 'host-':
                    resKey = prop[5:]
                elif prop[:10] == 'reservoir-':
                    resKey = prop[10:]
                if resKey in res:
                    instance[prop] = res[resKey]
                else:
                    print 'missing:', prop
        if C.OUTPUT_INSTANCES:
            print 'results:'
            F.printDict(instance)
        instances.append(instance)
        instanceId += 1
    return instances

def main():
    F.clock('test begin')

    # Obtain raw inputs
    elem = raw_input()
    lattice = raw_input()
    model = raw_input()
    latticeConstA = raw_input()
    latticeConstC = raw_input()
    options = raw_input()
    options = json.loads(options)
    print json.dumps(options, indent = 2)

    # If it's hcp crystal, process both a and c
    # Otherwise, process a only
    if lattice == 'hcp':
        latticeConsts = [float(latticeConstA), float(latticeConstC)]
    else:
        latticeConsts = [float(latticeConstA)]

    vacancy = Vacancy(elem, model, lattice, latticeConsts, options)

    # Obtain Results and pack them into required format
    vacancy.run()
    res = vacancy.getResult()
    instances = packResult(res)

    # Output results
    # Output pipeline edn 'json' file
    insEdn = json.dumps(instances, separators = (' ',' '), indent = 2)
    with open(os.path.abspath('output/results.edn'), 'w') as f:
        f.write(insEdn)
        
    # Output usual json file with all the information
    if C.SAVE_JSON:
        resJson = json.dumps(res, indent = 2)
        with open(os.path.abspath('output/summary.json'), 'w') as f:
            f.write(resJson)

    F.clock('test completed')

if __name__ == '__main__':
    main()
